				Conditional Execution
   Comparison Operators	
Boolean expressions ask a question and produce a Yes or No result which we use to control program flow
Boolean expressions using comparison operators evaluate to True / False or Yes / No
Comparison operators look at variables but do not change the variables
	Python      Meaning
	<           Less than
	<=          Less than or Equal to 
	==          Equal to
	>=          Greater than or Equal to
	>           Greater than
	!=          Not equal
	Remember: "=" is used for assignment.
  
  Indentation
Increase indent indent after an if statement or for statement (after :)
Maintain indent to indicate the scope of the block (which lines are affected by the if/for)
Reduce indent back to the level of the if statement or for statement to indicate the end of the block
Blank lines are ignored - they do not affect indentation 
Comments on a line by themselves are ignored with regard to identation
 So,identation is an essential part of Python. 
 We use indentation in lots of programming languages, often to demarcate blocks, to show where blocks start and a stop. But in Python, it's syntactically correct, if you make an error, if your indentation is wrong, after an if, you must indent, and you maintain the indent as long as you want to, to be in that same if block. And then, when you're done with the if block, you can reduce the indent.
In this rule of indenting, comment lines, and blank lines are completely ignored.

Warning: Turn Off Tabs!!
Atom automatically uses spaces for files with ".py" extension (nice!)
Most text editors can turn tabs into spaces - make sure to enable this feature
 Notepad++ : Settings -> Preferences -> Language Menu/Tab Settings
 TextWrangler : TextWrangler -> Preferences -> Editor Defaults
 Python cares a *lot* about how far a line is intended. If you mix tabs and spaces, you may get "indentation errors" even if everything looks fine 
So, we're gonna tend to put four spaces. Four spaces ends up being the normal thing that we do. You'll see, all the code that I write has four spaces for each indent. If I go in twice, I use eight spaces. We have this instinct of wanting to hit the tab key to move in four spaces. Now, the problem is that it might look the same on your screen, a tab, and four spaces, might line up the same place, depending on how tabs are set. But Python can get confused by that, so we tend to avoid using actual tabs in files.
So most programming text editors, like if you're using Notepad, or TextWrangler, there is a place to set the tabs, to say, "Don't put tabs in this document, "but every time I hit tab, move over four spaces."
You hit a tab, but it's like space, space, space, space. The nice thing about Atom, and this is the text editor we tend to recommend in this class. A, because it works on Windows,Linux, and Mac, but also because it automatically sets this up. As soon as you save your file with .py extension, you can sort of hit the tab key with impunity, and everything works perfectly. But, the key thing here is that Python insists that you get this right, and if you don't get this right, you're going to get indentation errors. They're just another syntax error.
So, if you're using something like TextWrangler, or Notepad, run around in the preferences, and you'll find something about expanding tabs, or maybe how many spaces each tab stop is supposed to be. So, you'd check these, and what this really is doing is telling your text editor, "Never put an actual tab "in a document, but somehow simulate "tab stops, using spaces."      

Increase / maintain after if or for
Decrease to indicate end of block
 So, here is a bit of code, it's got nested block. But it gives you the sense that you have to be very explicit when you're reading Python code, of whether the indent is the same between two lines, the same, increased, or decreased. Every time you increase it, you mean something, Every time you increase it, you mean something and literally, if it stays the same, you mean something, as well.
So, if we take a look at this, here, We have a line, and the next line has the same indent. 
This is an if, with a colon at the end, so we have to increase the indent, and now we're maintaining it.So,these two lines are part of that if, but now we have to de-indent it.So, whether you choose to de-indent this word, or this word, or whatever, where you do this de-indent affects the scope of how far this if statement lasts, right? it lasts up to, but not including, the line that's de-indented to the same level as the if. This is a de-indent, now, we have a blank line, which doesn't matter, and we maintain it.
And we have a for which we'll learn about, in the next chapter, which is a looping structure. Do a for, for runs this five times, it has a colon, and it also expects an indented block. Now, we have what's called a nested block, Where we have an if, and a colon, we go in some more. So this is like two indents, right? So,these are one indent, and these are two indents. This is a block,within a block, and then we de-indent. So that means this print is not part of the if statement, but is still part of the for statement. Then we de-indent again, and then that means this print is on the same level as that for statement. So, if you start thinking about this, you wanna be able to start thinking that these blocks are the start of the block, with the colon line, up to, but not including, this line that's been de-indented. So, the for goes this far, right? The for goes up to, but not including the line that's de-indented. The if goes up to, but not including the line that's de-indented. So, as you do this you'll sort of mentally start drawing these blocks, and pretty soon, you will start constructing them as blocks. It takes a while, but it doesn't take forever. 
  Think about begin/end blocks
But in Python, unlike other languages, this is very important, and it matters, and you can have syntax errors if you get it wrong. 'Cause you're really communicating the shape and the structure of your code, using these indents, and de-indents.

	
   