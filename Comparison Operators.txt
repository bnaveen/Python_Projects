				Conditional Execution
   Comparison Operators	
Boolean expressions ask a question and produce a Yes or No result which we use to control program flow
Boolean expressions using comparison operators evaluate to True / False or Yes / No
Comparison operators look at variables but do not change the variables
	Python      Meaning
	<           Less than
	<=          Less than or Equal to 
	==          Equal to
	>=          Greater than or Equal to
	>           Greater than
	!=          Not equal
	Remember: "=" is used for assignment.
  
  Indentation
Increase indent indent after an if statement or for statement (after :)
Maintain indent to indicate the scope of the block (which lines are affected by the if/for)
Reduce indent back to the level of the if statement or for statement to indicate the end of the block
Blank lines are ignored - they do not affect indentation 
Comments on a line by themselves are ignored with regard to identation
 So,identation is an essential part of Python. 
 We use indentation in lots of programming languages, often to demarcate blocks, to show where blocks start and a stop. But in Python, it's syntactically correct, if you make an error, if your indentation is wrong, after an if, you must indent, and you maintain the indent as long as you want to, to be in that same if block. And then, when you're done with the if block, you can reduce the indent.
In this rule of indenting, comment lines, and blank lines are completely ignored.

Warning: Turn Off Tabs!!
Atom automatically uses spaces for files with ".py" extension (nice!)
Most text editors can turn tabs into spaces - make sure to enable this feature
 Notepad++ : Settings -> Preferences -> Language Menu/Tab Settings
 TextWrangler : TextWrangler -> Preferences -> Editor Defaults
 Python cares a *lot* about how far a line is intended. If you mix tabs and spaces, you may get "indentation errors" even if everything looks fine 
So, we're gonna tend to put four spaces. Four spaces ends up being the normal thing that we do. You'll see, all the code that I write has four spaces for each indent. If I go in twice, I use eight spaces. We have this instinct of wanting to hit the tab key to move in four spaces. Now, the problem is that it might look the same on your screen, a tab, and four spaces, might line up the same place, depending on how tabs are set. But Python can get confused by that, so we tend to avoid using actual tabs in files.
So most programming text editors, like if you're using Notepad, or TextWrangler, there is a place to set the tabs, to say, "Don't put tabs in this document, "but every time I hit tab, move over four spaces."
You hit a tab, but it's like space, space, space, space. The nice thing about Atom, and this is the text editor we tend to recommend in this class. A, because it works on Windows,Linux, and Mac, but also because it automatically sets this up. As soon as you save your file with .py extension, you can sort of hit the tab key with impunity, and everything works perfectly. But, the key thing here is that Python insists that you get this right, and if you don't get this right, you're going to get indentation errors. They're just another syntax error.
So, if you're using something like TextWrangler, or Notepad, run around in the preferences, and you'll find something about expanding tabs, or maybe how many spaces each tab stop is supposed to be. So, you'd check these, and what this really is doing is telling your text editor, "Never put an actual tab "in a document, but somehow simulate "tab stops, using spaces."      

Increase / maintain after if or for
Decrease to indicate end of block
 So, here is a bit of code, it's got nested block. But it gives you the sense that you have to be very explicit when you're reading Python code, of whether the indent is the same between two lines, the same, increased, or decreased. Every time you increase it, you mean something, Every time you increase it, you mean something and literally, if it stays the same, you mean something, as well.
So, if we take a look at this, here, We have a line, and the next line has the same indent. 
This is an if, with a colon at the end, so we have to increase the indent, and now we're maintaining it.So,these two lines are part of that if, but now we have to de-indent it.So, whether you choose to de-indent this word, or this word, or whatever, where you do this de-indent affects the scope of how far this if statement lasts, right? it lasts up to, but not including, the line that's de-indented to the same level as the if. This is a de-indent, now, we have a blank line, which doesn't matter, and we maintain it.
And we have a for which we'll learn about, in the next chapter, which is a looping structure. Do a for, for runs this five times, it has a colon, and it also expects an indented block. Now, we have what's called a nested block, Where we have an if, and a colon, we go in some more. So this is like two indents, right? So,these are one indent, and these are two indents. This is a block,within a block, and then we de-indent. So that means this print is not part of the if statement, but is still part of the for statement. Then we de-indent again, and then that means this print is on the same level as that for statement. So, if you start thinking about this, you wanna be able to start thinking that these blocks are the start of the block, with the colon line, up to, but not including, this line that's been de-indented. So, the for goes this far, right? The for goes up to, but not including the line that's de-indented. The if goes up to, but not including the line that's de-indented. So, as you do this you'll sort of mentally start drawing these blocks, and pretty soon, you will start constructing them as blocks. It takes a while, but it doesn't take forever. 
  Think about begin/end blocks
But in Python, unlike other languages, this is very important, and it matters, and you can have syntax errors if you get it wrong. 'Cause you're really communicating the shape and the structure of your code, using these indents, and de-indents.
	Nested Decisions
 We already saw a nested indent,this is a nested if, so you can put an if within an if, and you can go as far deep as you want to go, like Russian dolls, and so, here we have X = 42. If it's one, we indent one, and then with this next thing we do, these are on the same level of indent, but now we see an if, and it has to indent further.So this is like two in, eight spaces. Then we de-indent back, actually we'd de-indent back two. So if you watch this, and you take a look at how this works, it runs to here. Come in here, the answer is "Yes, X is greater than one." Print this, is X less than 100, well, it's 42, so the answer is yes. So, it runs this, and then it kind of continues back to there, and you can also think of drawing boxes around this.This is one if box, and then, within that if box, there is another if box, and again, it's the indent. The indent block, up to, but not including where the de-indent happens. And this here is like two backwards de-indents. So, it ends two blocks, so two blocks are ended by where we place this. We could move this in, or we could move this out. We could have it all the way into here, we could have it to here, or here, and where we put that line depends on how the ends of these blocks are going to work out.           	

    Two-way Decisions
Sometimes we want to do one thing if a logical expression is true and something else if the expression is false 	
It is like a fork in the road - we must choose one or the other path but not both 
 One form, that's a one-branch if that we just saw, but then, you could also have what's called a two-branch if. 
The basic idea of a two-branch if is that you're gonna come in, you're gonna ask a question, and you're gonna go one direction, if it's yes, and another direction, if it's no. We call this an if, then, else, it's kind of like a fork in the road. The way to think about it is, depending on the output of this question, we're gonna pick one or two of these, but if we pick one, the other one's never gonna happen. 
So, it's like an either, or, we're either gonna go one way, or we're gonna go the other way. But there is no path where we somehow go through both of them, that doesn't happen.
    Two-way Decisions with else:
 The syntax that we use for this is what we call the if, then, else. So, the first part is a normal if, with an indent, and then we de-indent, and then this is another reserved word, else with a colon, and then we re-indent. This is really, ends up being part of a whole block here, and the else is, this is the part that runs if it's false, and this is the part that runs if it's true. 
 The first branch of the if, the first indented block, is what runs if it's true, and then the second indented block is the one that runs if it's false.
So, here we go, if X is greater than two, in this case, it's yes, we're gonna print bigger. And then we're gonna be all done. So we do one, and so, this one did run, and this one did not run. So, basically, with an if, then, else, one of the two branches is gonna run, but there's no case in which both branches run.
    Visualize Blocks
Again, you sort of draw these blocks around these things, mentally, and in this one, you sort of take,from the if. The else is really part of the block,up to, but not including, that print, which is back, de-indented back to the same level as the if statement.
Python is actually one of the more elegant languages, even though, after a while, this indenting when you get too far in, it gets a little bit complex. This is a good way to visualize this, with these indents.      