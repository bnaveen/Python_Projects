					Chapter 3
				Conditional Execution
 In conditional execution, we meet the if statement. The if statement is where Python can go one way, or another way, and it's the beginning, and sort of our way of making Python make decisions for us.
Sequential code, we just, you know, do some things. Sometimes, that's useful, but now we can have our code check something and then make a decision based on that thing. 
So, the Conditional steps in Python are pretty straightforward. The key word that we're going to use is the if statement. And so if is a reserved word, and the if statement has, a part of it, a question that it asks. This is asking if X is less than 10. The colon is the end of the if statement, and then we begin an indented block of text. The way this works, in this particular thing is, this line is the conditional line.If the question is true, the line executes, and if the question is false, the line will skip. And you can think of it the way this is, right? 
 X is five, ask a question, is it 10, or not? These questions do not harm the value of X. If it is, then we run this code, and then we sort of re-join here, and we adjust this next if. And if that's true, we do this code, and then we do there. But,in this case, it's gonna be false, because X is not less than 20, so it just continues down here. If we look at how this works, it runs, it runs this line, then it sees this question, it skips that line. So this line does not run, and so smaller prints out, and finis prints out, okay? And so that's the basic idea of an if statement, and the indentation, when we are done with an if statement, we de-indent back, and there's this little block. This is one if statement, and this is another if statement, and these are the two conditional lines, that either run, or they don't run, depending on the question, and the answer to that question.              			
   Comparison Operators	
 So, we have a number of different comparison operators that we can use to ask these "true-false" questions, that say, "Is this true?" So, again, we're kind of limited to the keys that were on computer keyboards in the 1940s, and 1950s.
 Less than, less than or equal to. So, we didn't have fancy math characters, so we just concatenated less than equal to be less than, or equal to. This double equals is asking, Is this equal to?" So that's a little tricky, the equals sign is that assignment operator.    
Boolean expressions ask a question and produce a Yes or No result which we use to control program flow
Boolean expressions using comparison operators evaluate to True / False or Yes / No
Comparison operators look at variables but do not change the variables
	Python      Meaning
	<           Less than
	<=          Less than or Equal to 
	==          Equal to
	>=          Greater than or Equal to
	>           Greater than
	!=          Not equal
	Remember: "=" is used for assignment.
  
  Indentation
Increase indent indent after an if statement or for statement (after :)
Maintain indent to indicate the scope of the block (which lines are affected by the if/for)
Reduce indent back to the level of the if statement or for statement to indicate the end of the block
Blank lines are ignored - they do not affect indentation 
Comments on a line by themselves are ignored with regard to identation
 So,identation is an essential part of Python. 
 We use indentation in lots of programming languages, often to demarcate blocks, to show where blocks start and a stop. But in Python, it's syntactically correct, if you make an error, if your indentation is wrong, after an if, you must indent, and you maintain the indent as long as you want to, to be in that same if block. And then, when you're done with the if block, you can reduce the indent.
In this rule of indenting, comment lines, and blank lines are completely ignored.

Warning: Turn Off Tabs!!
Atom automatically uses spaces for files with ".py" extension (nice!)
Most text editors can turn tabs into spaces - make sure to enable this feature
 Notepad++ : Settings -> Preferences -> Language Menu/Tab Settings
 TextWrangler : TextWrangler -> Preferences -> Editor Defaults
 Python cares a *lot* about how far a line is intended. If you mix tabs and spaces, you may get "indentation errors" even if everything looks fine 
So, we're gonna tend to put four spaces. Four spaces ends up being the normal thing that we do. You'll see, all the code that I write has four spaces for each indent. If I go in twice, I use eight spaces. We have this instinct of wanting to hit the tab key to move in four spaces. Now, the problem is that it might look the same on your screen, a tab, and four spaces, might line up the same place, depending on how tabs are set. But Python can get confused by that, so we tend to avoid using actual tabs in files.
So most programming text editors, like if you're using Notepad, or TextWrangler, there is a place to set the tabs, to say, "Don't put tabs in this document, "but every time I hit tab, move over four spaces."
You hit a tab, but it's like space, space, space, space. The nice thing about Atom, and this is the text editor we tend to recommend in this class. A, because it works on Windows,Linux, and Mac, but also because it automatically sets this up. As soon as you save your file with .py extension, you can sort of hit the tab key with impunity, and everything works perfectly. But, the key thing here is that Python insists that you get this right, and if you don't get this right, you're going to get indentation errors. They're just another syntax error.
So, if you're using something like TextWrangler, or Notepad, run around in the preferences, and you'll find something about expanding tabs, or maybe how many spaces each tab stop is supposed to be. So, you'd check these, and what this really is doing is telling your text editor, "Never put an actual tab "in a document, but somehow simulate "tab stops, using spaces."      

Increase / maintain after if or for
Decrease to indicate end of block
 So, here is a bit of code, it's got nested block. But it gives you the sense that you have to be very explicit when you're reading Python code, of whether the indent is the same between two lines, the same, increased, or decreased. Every time you increase it, you mean something, Every time you increase it, you mean something and literally, if it stays the same, you mean something, as well.
So, if we take a look at this, here, We have a line, and the next line has the same indent. 
This is an if, with a colon at the end, so we have to increase the indent, and now we're maintaining it.So,these two lines are part of that if, but now we have to de-indent it.So, whether you choose to de-indent this word, or this word, or whatever, where you do this de-indent affects the scope of how far this if statement lasts, right? it lasts up to, but not including, the line that's de-indented to the same level as the if. This is a de-indent, now, we have a blank line, which doesn't matter, and we maintain it.
And we have a for which we'll learn about, in the next chapter, which is a looping structure. Do a for, for runs this five times, it has a colon, and it also expects an indented block. Now, we have what's called a nested block, Where we have an if, and a colon, we go in some more. So this is like two indents, right? So,these are one indent, and these are two indents. This is a block,within a block, and then we de-indent. So that means this print is not part of the if statement, but is still part of the for statement. Then we de-indent again, and then that means this print is on the same level as that for statement. So, if you start thinking about this, you wanna be able to start thinking that these blocks are the start of the block, with the colon line, up to, but not including, this line that's been de-indented. So, the for goes this far, right? The for goes up to, but not including the line that's de-indented. The if goes up to, but not including the line that's de-indented. So, as you do this you'll sort of mentally start drawing these blocks, and pretty soon, you will start constructing them as blocks. It takes a while, but it doesn't take forever. 
  Think about begin/end blocks
But in Python, unlike other languages, this is very important, and it matters, and you can have syntax errors if you get it wrong. 'Cause you're really communicating the shape and the structure of your code, using these indents, and de-indents.
	Nested Decisions
 We already saw a nested indent,this is a nested if, so you can put an if within an if, and you can go as far deep as you want to go, like Russian dolls, and so, here we have X = 42. If it's one, we indent one, and then with this next thing we do, these are on the same level of indent, but now we see an if, and it has to indent further.So this is like two in, eight spaces. Then we de-indent back, actually we'd de-indent back two. So if you watch this, and you take a look at how this works, it runs to here. Come in here, the answer is "Yes, X is greater than one." Print this, is X less than 100, well, it's 42, so the answer is yes. So, it runs this, and then it kind of continues back to there, and you can also think of drawing boxes around this.This is one if box, and then, within that if box, there is another if box, and again, it's the indent. The indent block, up to, but not including where the de-indent happens. And this here is like two backwards de-indents. So, it ends two blocks, so two blocks are ended by where we place this. We could move this in, or we could move this out. We could have it all the way into here, we could have it to here, or here, and where we put that line depends on how the ends of these blocks are going to work out.           	

    Two-way Decisions
Sometimes we want to do one thing if a logical expression is true and something else if the expression is false 	
It is like a fork in the road - we must choose one or the other path but not both 
 One form, that's a one-branch if that we just saw, but then, you could also have what's called a two-branch if. 
The basic idea of a two-branch if is that you're gonna come in, you're gonna ask a question, and you're gonna go one direction, if it's yes, and another direction, if it's no. We call this an if, then, else, it's kind of like a fork in the road. The way to think about it is, depending on the output of this question, we're gonna pick one or two of these, but if we pick one, the other one's never gonna happen. 
So, it's like an either, or, we're either gonna go one way, or we're gonna go the other way. But there is no path where we somehow go through both of them, that doesn't happen.
    Two-way Decisions with else:
 The syntax that we use for this is what we call the if, then, else. So, the first part is a normal if, with an indent, and then we de-indent, and then this is another reserved word, else with a colon, and then we re-indent. This is really, ends up being part of a whole block here, and the else is, this is the part that runs if it's false, and this is the part that runs if it's true. 
 The first branch of the if, the first indented block, is what runs if it's true, and then the second indented block is the one that runs if it's false.
So, here we go, if X is greater than two, in this case, it's yes, we're gonna print bigger. And then we're gonna be all done. So we do one, and so, this one did run, and this one did not run. So, basically, with an if, then, else, one of the two branches is gonna run, but there's no case in which both branches run.
    Visualize Blocks
Again, you sort of draw these blocks around these things, mentally, and in this one, you sort of take,from the if. The else is really part of the block,up to, but not including, that print, which is back, de-indented back to the same level as the if statement.
Python is actually one of the more elegant languages, even though, after a while, this indenting when you get too far in, it gets a little bit complex. This is a good way to visualize this, with these indents.      
                   Chapter 3 Conditional B 
 Some more complex conditional statements that build on this concept of if and if then else.
        Multi-way
  The first thing we're gonna look at is the multi-way branch. And so, the idea is it's kind of like the if then else where you're gonna pick one of two, but now we can pick one of three,or one of four or one of five. And it introduces a new concept called the elif. The elif is another reserve word inside Python. And the way it works is; it's probably best to look at this here where it checks the first one and if it's a true then it runs that and then it's done. It doesn't check them all. It's not like it sees that there are two logical conditions. It actually checks them the first one. And how you order these matters as we'll see in a bit. And so if the first one is true, it runs. If the first one is false, and the second one is true, it runs this one and it's done.And if the neither of them are true it falls through and there's an else clause that is otherwise and it runs that. So basically, it's either gonna run one and then skip the other two. Or it is going to skip one, skip two and then run this one. But it only runs, in this case one of them but the important thing is it checks these questions in order. And it doesn't check the second question until it finds it, the first; it doesn't check the second question until it knows the first question is false. So if the first question is true you're done.You're done and you're done with this. You're done with the whole block at that point. So only one of these three is going to execute in that block.
  So in this case, we ran that, and we didn't run that; and we didn't run that. Again, one of them is gonna run.
 They're checked in order. These questions are checked in order;not out of order. It doesn't look ahead. It just checks in the order that you wrote it. You're the one that wrote that order.
    And so, there's a couple of variations on this multi-way. You can have no else.You can have no else, as in this case. And this just means that it might not run any of them. In this case x is five, so it's not less than two, but then it runs this. But if x was 50, for example. If x was 50; then this would be false and it would skip,and this would still be false and it would skip.And neither of these two would run. So if you don't have an else you're not guaranteed that one of them is gonna run because else is like the catch-all; if the other ones are all false then the else is the one that runs. 
	Similarly you can have many elifs. But this is where it's really important for you to make sure you know what order they're being taken in. So I've got; if this is true,it runs. It goes all the way to the bottom. If this was If it's false,false,false,true; it runs this one and it's done. If on the other hand it looks at it as false; If it runs false,false,false,false;they're all false, then it runs the else. This one has an else. They don't have to have them. The key is you can have more than one of these elifs. okay? So I got a couple little things.
       Multi-way Puzzles
the question is; Which will never print regardless of the value for x? are there, looking at the three lines or four lines of code; x equals something. Are there lines of code that will never execute regardless of the value for x? so, we come in here and if x is less than or equal to two it's gonna run this first thing. And if x is greater than or equal to two it's gonna run this. And if neither of those are true then it's gonna run this. Well, the weird thing is all numbers are either less than two or greater than or equal to two. I carefully constructed this to the point where it would never run this line of code. It is either gonna run this one, or run that one but it's not ever gonna run this one. So that one's like a weird disfunctional one that I constructed.
           	